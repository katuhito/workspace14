/*ポインター変数*/

//ここまでのCプログラムでは、文字列を示すchar*(char型へのポインター)変数と配列変数を除いて、変数は値そのものをメモリに格納していた
//変数の宣言は、型名と変数名を指定する。オプションで初期化子を指定する。
//ポインター変数では、変数と異なり、型名で指定した値を格納したメモリの先頭アドレスを格納する。ポインタという名前が示すように、ポインタ変数に格納されるのはプログラムが直接扱う数値や文字列などの値そのものではなく、型で指定した値が格納された目の鯉丈のアドレスである。
//ポインタ変数の宣言では、型名、ポインタ変数を表す「*」と変数名オプションで初期化子を指定する。
//重要なのは、ポインタ変数が格納するのは値そのものではなく、その値を格納したメモリ上のアドレスであるという点。

//ポインタ変数のために確保されるメモリのサイズは、CPUアーキテクチャに依存する。例えば、64ビットCPU用のCコンパイラであれば、CPUは8バイトを確保する。ただし、64ビットCPUを32ビットモードで使用する（32ビットOSを使用する）場合は、メモリアクセスに使用するアドレスは32ビットとなる。
//ポインタ変数のサイズについては、プログラマーが任意のサイズに指定できるあたいようの型（例えば16ビット整数用にint16_tを指定するなど）とは異なる。そのため、printf用の書式指定子も「%p」という専用のものを使用する。

//ポインタ変数の値（ポイントしているメモリのアドレス）を出力する
char *hello = "hello";
printf("address of hello = %p\n", hello); //リテラルhelloのメモリ先頭アドレスを出力

//アドレス演算子（&）
//Cプログラムでリテラルを記述すると、自動的にリテラルを格納したメモリのアドレスを取得できる。それ以外の値をポインタで指し示すには、アドレス演算子（単項演算子&）を使用する。
//アドレス演算は、&に続けて変数名を記述する。結果は指定した変数のアドレスである。
//アドレス演算子（&）=>&変数名;

//コードのアドレス演算の仕組み
int32_t a = 8;   //int32_t型の変数aに8を格納する
int32_t *a_ptr = &a;  //int32_t型へのポインタ変数a_ptrは変aのアドレスポイントとなるß
//=>int32_t a = 8;と記述すると、メモリ上に4バイト（32ビット）のメモリ領域が確保され、8で初期化される。以降、プログラム内でaと書くと、確保した4バイトの領域の先頭アドレスの内容が使用できる。

printf("%i\n", a);  // =>8 単にaと書くと変数に格納された値の取り出しとなる
int x = 8 + a;  //xは16となる。単にaと書くと変数に格納された値の取り出しとなる
a = 32;   //同じ領域に32を代入
printf("%i\n", a); // =>32

//変数に対してアドレス演算子を適用すると、確保した4バイトの領域のないよう(値)ではなく、領域の先頭アドレスが取り出される。
int32_t *a_ptr = &a;   //aのアドレスをa_ptrに代入
printf("%p = %p\n", &a, a_ptr);   //aのアドレスを取得するには&演算が必要である
//a_pyrの内容はaのアドレスなので同じ値が出力される

//アドレス演算子を適用する被演算子には、メモリ上の位置を指定する必要がある。従って、定数や演算を記述することはできない。
int32_t *a = &3;   //コンパイルエラー。int型の右辺値のアドレスは取得できない。
int32_t *b = &(a + 3);   //コンパイルエラー。int型の右辺値のアドレスは取得できない。


//間接演算子(単項演算子*)
// 間接演算子をポインタ変数に適用すると、ポインタ変数がポイントしているアドレスの内容に対してアクセスすることができる。
// 間接演算子 => *ポインタ変数
// 間接演算子の仕組み：1
int32_t a = 8;  //1:
int32_t *a_ptr = &a;  //2:a_ptrは変数aをポイント
printf("%i\n", *a_ptr);  //3: =>8 *a_ptrは変数aの内容を示す

//間接演算子の仕組み：2
a = 32;  //aに32を代入
printf("%i\n", *a_ptr);  // =>32 *a_ptrは変数aの内容
*a_ptr = 64;  //4: a_ptrがポイントするメモリ領域に64を代入する
printf("%i\n", a);  //5: =>64 aの内容は64である。

//間接演算子を適用したポインタ変数はb、ポイントしている（アドレス演算子でアドレスを取り出した）変数のエイリアスとして使用できる。つまり、値を取り出すことも、代入することもできるという点が重要である。
//変数が持つ値に対してポインタ変数を経由して間接的にアクセスするために「間接演算子」と呼ばれるわけである。

