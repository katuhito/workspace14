/*定数*/

//定数はコード内に埋め込まれた関数であり、メモリ上には確保されない。
//特徴：アドレスを持たない
//左辺値ではない。（右辺値である。）

//定数の使用例
int a = 8; //定数8で変数aを初期化する。
int *a = &8;  //エラー。定数はアドレスを持たない。
8 = a;  //エラー。定数は左辺値ではない。


/*リテラル*/

//リテラルは文字列のために用意された言語要素であり、文字配列の代わりに使用することができる。
//メモリ上に確保されるが、代入はできない。
//特徴：アドレスを持つ
//左辺値ではない。(右辺値である。)

//リテラルの使用例
char hello[8];
strcpy(hello, "hello");  // strcpyの第2引数としてリテラルのアドレスを与える。
"hello" = "bye";   //エラー。リテラルは左辺値ではない。


/*変数*/

//変数はメモリ上の領域として確保され、その大きさは指定した型のサイズとなる。プログラム内では、変数名は該当する領域の内容を意味する。変数のアドレスを取得するには、アドレス演算子（単項演算子&）を使用する。
//特徴：アドレスを持つ
//左辺値である

//変数の使用例
int32_t a = 32;  //32ビット（4バイト）の領域を割り当てて、32を格納する。
int32_t *a_ptr = &a;  //a_ptrにaのアドレスを格納する。
printf("%i\n", *a_ptr);  // => 32 (a_ptrに間接演算子を適用して変数aの内容を参照)
printf("aのアドレスは%p == %p\n", &a, a_ptr);  //アドレスを表示



/*ポインタ変数*/

//ポインタ変数は、アドレスを格納するための変数である。宣言時に通常の変数と区別するために、変数の先頭に*を付ける。
//プログラム内では、ポインタ変数は該当する領域の内容を意味する。この点については通常の変数と同じである。通常の変数との最大の違いは、間接演算子（単項演算子*）を使用して、格納したアドレスに対して内容の取得や設定ができることである。
//特徴：アドレスを持つ
//左辺値である
//間接演算子を適用して格納したアドレスに対して参照や設定が可能

//ポインタ変数の使用例
int32_t *p;  //32ビット領域のアドレスをポイントするためのポインタ変数
int32_t x = 8;
p = &x;   //変数にアドレス演算子を適用して取得したアドレスを代入
*p = 48;  //間接演算子を適用して変数xのアドレスに32ビットの48を設定する。（アドレスを48に設定する）
printf("%i\n", x);  // => 48



/*配列*/

//配列名は、配列の先頭のアドレスに名前を付けてアクセスできるようにしたものである。
//通常のポインタ変数と異なり名前を使った代入操作はできない。
//ただし、配列名を直接記述して、配列に対するポインタとして使用できる。この場合、配列名を通して配列のアドレスを取得することができる。
//配列の内容（各要素）にアクセスするには、配列名の直後に[]を付けてインデックスを指定する。
//特徴：左辺値ではない。(右辺値である)
//アドレスを持つ
//ポインタ変数と異なりアドレスを格納しているわけではないが、配列の先頭要素のアドレス（ポインタ）として使用可能

//配列の使用例
int32_t a[] = {0,1,2};
a[0] = 8;  //要素0（0番目の要素）に8を代入
printf("%i\n", a[1]);  //1番の要素を参照
int32_t *aptr = a;  //配列名を直接記述すると配列の先頭要素のアドレスが得られる。(アドレス演算子は不要)
printf("%i\n", *aptr);  // => 8, 上の行でaptrは配列の先頭要素をポイントしている。
aptr = &a[1];   //要素1のアドレスを取得。個々の要素に対してはアドレス演算子を適用できる
printf("%i\n", *aptr); // => 1, 上の行でaptrは配列の2番目の要素をポイントしている。



/*関数*/

//関数は、メモリ上に展開されたプログラムコード（機械語）である。
//関数名は、関数のアドレスを示す。現代のCPUはセキュリティ上の理由からメモリ上のコードを書き換えようとすると例外を起こす者がほとんどである。そのため、関数名を使って代入操作はできない。(Cでは関数は左辺値ではないので通常の方法では書き込めない)しかし、関数名を使ってアドレスを取得することができる。
//特徴：左辺値ではない。（右辺値である）
//アドレスを持つ
//(引数リスト)を後置して呼び出しができる。

//関数の使用例
int32_t func()
{
    return 32;
}

int32_t(*x)() = func;  //関数に関するポインタ変数の書き方はややこしいので注意。
                       //int32_t(*x)() = func();と記述すると関数呼び出しの結果の代入となる。
printf("%i\n", x());  // => 32 関数ポインタ変数xを通してfuncを呼び出す。
printf("%i\n", (*x)());  // => 32 関数ポインタ変数xを通してfuncを呼び出す別の（正確な）書き方
                         //関数を呼び出しの()の方が*よりも優先度が高いので、間接演算子を関数ポインタ変数変数に適用する場合には()で囲む必要がある


/*practice8.2*/

//次のプログラムが32を出力する理由
int32_t a = 32;
int32_t *ap = &a;
int32_t *b = ap;
printf("%i\n", *b); // => 32
//=> ポインタ変数bはポインタ変数apの内容、つまり、変数aのアドレスで初期化されている。そのためポインタ変数bに間接演算を適用すると、変数aが格納する値(=32)を取得できるため

//次のリストに対して設問を満たすプログラムを作成。
int32_t array[] = {1,2,3,4};
unsigned char u = 'x';

//=>array配列の先頭アドレスで初期化されたポインタ変数p()を宣言
//array配列の値3のアドレスで初期化されたポインタ変数p3を宣言
//変数uのアドレスで初期化されたポインタ変数upを宣言
//p0,p3,upがポイントする値を出力するprintf関数を記述する
//出力 => 1,3,x

