## 関数の定義

```
書式：指定子　型名　識別子(パラメータリスト)　複合文
```
- 型名は、関数が返す値の型の名前である。値を返さない関数は特殊な型名のvoidを指定する。
- 識別子は、関数の名前である。C言語の識別子のルールでは、英大文字または_で始まり、英大文字や英小文字または、_や数字が続く文字である。uncodeの国際文字を使用することもできる。
- パラメータリストは()内に「,」で区切って型と変数名のペアを並べる。パラメータも関数同様に指定子をつけることができる。
- パラメータが１つもない場合にはvoidキーワードを記述する。特にパラメータリスト内のvoidが意味を持つのは関数定義ではなく、関数プロトタイプである。

- 複合文は関数本体である。複合文なので、0個以上のC言語の文を{}内に記述して関数の内容とする。値を返す関数の場合には、複合文の最後の文は、関数から値を返すreturn文となる。しかし、C言語の文法では必ずしもreturn文を記述する必要はない。
- return文なしで関数が終わった場合、返り値は不定である。（ただし、main関数だけはreturn文がなければ0を返す。）
- return文で終わらない関数は、記述漏れなどのプログラムのバグがほとんどなので、コンパイラは警告を出す。

## EX9.1:関数の定義
- 関数定義の指定子には、externとstaticがある。この２つの指定子は、1つのプログラムが複数のソースファイルから構成される場合に意味を持つ。
- externは既定の設定で、他のソースファイルから指定した関数を呼び出すことができる。
- staticは、関数を定義したソースファイル内からのみ呼び出すことができる。
- ch09-01.c
```
#include <stdio.h>

extern int ex2(int x, int y);  //ch09-02.cの関数ex2の関数プロトタイプ

extern int ex1(int x, int y)
{
    printf("ex1:%i\n", x + y);
    return x + y;
}
int main()
{
    ex2(5, 6);
}
```
- ch09-02.c
```
#include <stdio.h>

extern int ex1(int x, int y);  // ch09-01.cの関数ex1のプロトタイプ

extern int ex2(int x, int y)
{
    printf("ex2:%i\n", x * y);
    return ex1(x, y);
}
```
ch09-02.cに定義したex2関数をch09-01.cのmain関数から、ch09-01.cに定義したex1関数をch09-02.cのex2関数から、それぞれ呼び出すことができる。

関数プロトタイプを記述しなかった場合、clangはc99違反という警告を出すが、コンパイルは成功する。

## 演習1
ch09-01.cとch09-02.cそれぞれのソースコードから、extern指定子を削除してからコンパイル、実行して結果が変わらないことを確認する。

externを指定するということは、複数のファイルに同じ関数を参照させるということである。複数のソースファイルを呼び出す関数については、ヘッダーファイルに関数プロトタイプを記述して、各ソースファイルはヘッダーファイルを#includeディレクティブで取り込むようにする。そうすれば、関数プロトタイプを修正する必要が生じても、修正箇所を最大２か所までとすることができる。

少ない記述で済ませるほうが、無用なタイプミスなどによるコンパイルエラーを抑制することができる。

関数にstatic指定子を適用すると、その関数を呼び出せるのは同じファイル内の関数に限定される。

- ch09-03.c
```
#include <stdio.h>

extern int ex2(int x, int y); //ex2関数のプロトタイプで、ex2はch09-04.cにある
static int ex1(int x, int y)  //ex1はstatic指定しているのでこのファイル内からのみ呼び出すことができる
{
    printf("ch09-03-ex1: %i\n", x + y);
    return x + y;
}
int main()
{
    ex1(2, 3);
    ex2(5, 6);
}
```
- ch09-04.c
```
#include <stdio.h>

static int ex1(int x, int y) //ex1はstatic指定しているのでこのファイル内からのみ呼び出せる。
{
    printf("ch09-04-ex1: %i\n", x + y);
    return x + y;
}
extern int ex2(int x, int y) //別のファイルから呼び出せる関数
{
    printf("ex2: %i\n", x * y);
    return ex1(x, y);
}
```
ch09-04.cに定義したex2関数をch09-03.cのmain関数から呼び出している。一方で、ex1関数は２つのソースファイル内でstatic指定子をつけて定義している。指定子は関数を定義したソースファイル内に閉じ込める。そのため、ch09-03.cのmain関数から呼び出すex1関数はch09-03.cで定義したex1関数、ch09-04.cのex2関数から呼び出すex1関数はch09-04.cで定義したex1関数となる。

## 演習2
ch09-03.cとch09-04.cからstatic指定子を削除すると、extern指定したものとして扱われる。このとき、同じ識別子が複数のソースファイルで競合するためリンク時にエラーとなって実行ファイルが作成されない。実際にソースファイルを修正して確認してみる。

static指定子をつけて関数を定義するメリット

- 他のファイルから呼び出す必要がない、あるいは他のファイルから呼ばれたくない関数を定義できる。
- リンクが少しだけ高速になる可能性がある。

古い形式の関数定義には、パラメータリストにはパラメータのみを記述する。パラメータの型については、パラメータリストと関数本体の複合文の間に変数宣言の形式で記述をする。
- ch09-05.c
```
#include <stdio.h>

//lenで指定した数だけCで指定した文字を出力する関数
int test(len, c)
  int len; //出力する関数
  char c; //出力する文字
{
    for (int i = 0; i < len; i++) {
        printf("%c", c);
    }
    puts("");
    return len;
}

int main()
{
     test(4, '!', 8); //余分なパラメータ８があるが、コンパイラは警告を出力しない。
}

//実行結果
//!!!!
```
この形式はC11でも認められているが、この書き方は、互換性を維持するためにコンパイラが関数呼び出しのパラメータをチェックしないという致命的な問題を持つ、したがって、あくまで古いCのソースコードを読むための知識として覚えておくだけで、新規に作成するプログラムではない。ということに注意である。




